#compdef i

shift words
local subcmds=()
local w
local continue_more=0
local options_count=0
for w in $words ; do
  if [ "$continue_more" -gt 0 ] ; then
    (( continue_more-- ))
    continue
  fi
  if [ "$w[1]" = '-' ] ; then
    continue_more=$(i $subcmds help | sed -nE "s/^  -$w[-1]([^-]*)--.*$/\1/p" | wc -w)
    (( options_count += 1 + continue_more ))
    continue
  fi
  local arg_type="$(i $subcmds help -a | awk "/^  $w/{print \$2}")"
  if [ "$arg_type" != CMD ] ; then
    local last_command=$w
    break
  fi
  local subcmds=( $w $subcmds )
done

if (( $#subcmds + 1 + $options_count >= $#words )) ; then
  if (( $#subcmds + $options_count == $#words )) ; then
    local subcmds=()
  fi
  local cmds=("${(@f)$(
    i ${subcmds} help -a | sed -nEe 's#^  ([^ ]*)[^-]*-- (.*)#\1[\2]#p'
  )}")
  _values "i $subcmds command" $cmds
else
  local current_argument_pos=$(( $CURRENT - $#subcmds - $options_count - 1 ))
  local argument_type=$(
    i $subcmds help -a |
    sed -nE "s/^  ($last_command.*[^ ]) +--.*$/\1/p" |
    awk "{ \
      if(NF <= $current_argument_pos) print tolower(\$NF) ; \
      else print tolower(\$$current_argument_pos) \
    }" |
    tr _ - | tr -d \[ | tr -d \]
  )
  if [ "$argument_type" = file ] ; then
    _files
  elif [ -n "$argument_type" ] ; then
    local completions=($(i ${subcmds} _list-${argument_type}s))
    _describe "$argument_type" completions
  fi
fi
